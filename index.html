<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0f172a" />
  <title>Marcaci√≥n de Fotos ‚Äî PWA</title>
  <style>
    :root{
      --bg:#0f172a; --card:#111827; --muted:#94a3b8; --fg:#e5e7eb;
      --accent:#22c55e; --accent-2:#3b82f6; --danger:#ef4444;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Inter,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#0b1024,#0f172a);color:var(--fg)}
    .wrap{max-width:1100px;margin:24px auto;padding:16px}
    h1{font-size:clamp(1.25rem,2.5vw,1.8rem);margin:0 0 12px;display:flex;align-items:center;gap:10px}
    p.small{color:var(--muted);margin:0 0 16px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    .card{background:rgba(17,24,39,.7);backdrop-filter: blur(6px);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    label{display:block;font-size:.9rem;margin:10px 0 6px 2px;color:#cbd5e1}
    input[type="text"],input[type="number"],input[type="file"],input[type="datetime-local"],select,textarea{width:100%;padding:10px 12px;border-radius:12px;border:1px solid rgba(148,163,184,.25);background:#0b1220;color:var(--fg);outline:none;font-family:inherit}
    input[type="range"]{width:100%}
    textarea{resize:vertical;min-height:60px}
    select:disabled{opacity:0.6;cursor:not-allowed}
    details summary{padding:8px 0;margin:8px 0}
    details[open] summary{margin-bottom:8px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .btns{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
    button{cursor:pointer;border:1px solid rgba(255,255,255,.08);background:linear-gradient(180deg,#374151,#1f2937);color:var(--fg);padding:10px 14px;border-radius:8px;font-weight:500;box-shadow:0 1px 3px rgba(0,0,0,.2)}
    button.primary{background:linear-gradient(180deg,#1f2937,#111827);border:1px solid #374151}
    button.secondary{background:linear-gradient(180deg,#4b5563,#374151);border:1px solid #6b7280}
    button.danger{background:linear-gradient(180deg,#7f1d1d,#991b1b);border:1px solid #dc2626}
    .install{background:linear-gradient(180deg,#1f2937,#111827);border:1px solid #374151}
    .preview{width:100%;display:block;max-height:70vh;border-radius:12px;background:#000;object-fit:contain}
    .kv{display:flex;justify-content:space-between;gap:6px;color:#9ca3af;font-size:.85rem;margin-top:6px;flex-wrap:wrap}
    .chip{padding:4px 8px;border-radius:999px;background:#0b1220;border:1px solid rgba(148,163,184,.2);color:#cbd5e1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:120px;min-width:0}
    footer{margin-top:18px;color:#94a3b8;font-size:.85rem}
    .hint{font-size:.8rem;color:#93c5fd}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
  </style>
  <!-- Estos enlaces se completan din√°micamente para mantener el archivo √∫nico -->
  <link id="manifestLink" rel="manifest" href="#">
  <link id="appleTouchIcon" rel="apple-touch-icon">
</head>
<body>
  <div class="wrap">
    <h1>
      Marcaci√≥n Fotos
      <button id="installBtn" class="install" style="display:none">Instalar</button>
    </h1>
    <p class="small">Registra y marca fotos con informaci√≥n del proyecto.</p>
    <p class="small" style="margin-top: 8px; color: #f59e0b;">Los campos marcados con (*) son obligatorios</p>

    <div class="grid">
      <section class="card">
        <!-- Fecha y hora de creaci√≥n (oculto) -->
        <input type="hidden" id="fechaCreacion">
        
        <!-- Fecha elegida por el usuario -->
        <label for="fecha">Fecha *</label>
        <input id="fecha" type="datetime-local" required />

        <!-- √Årea -->
        <label for="area">√Årea *</label>
        <select id="area" required>
          <option value="">Selecciona un √°rea...</option>
          <option value="T√∫nel Gr√∫a Puente">T√∫nel Gr√∫a Puente</option>
          <option value="Casa de M√°quinas">Casa de M√°quinas</option>
          <option value="Transformador">Transformador</option>
          <option value="Vertedero">Vertedero</option>
          <option value="Embalse">Embalse</option>
          <option value="Obra de Toma">Obra de Toma</option>
        </select>

        <!-- Frente (dependiente del √°rea) -->
        <label for="frente">Frente *</label>
        <select id="frente" required disabled>
          <option value="">Primero selecciona un √°rea</option>
        </select>

        <!-- Foto -->
        <label for="file">Fotograf√≠a *</label>
        <input id="file" type="file" accept="image/*" required />

        <!-- Descripci√≥n de la foto -->
        <label for="descripcionFoto">Descripci√≥n de la fotograf√≠a *</label>
        <textarea id="descripcionFoto" rows="2" placeholder="Ej: Vaciado de concreto en t√∫nel" required></textarea>

        <!-- Observaciones -->
        <label for="observaciones">Observaciones</label>
        <textarea id="observaciones" rows="3" placeholder="Observaciones adicionales (opcional)"></textarea>

        <!-- Configuraci√≥n de marca de agua (colapsable) -->
        <details style="margin-top:15px">
          <summary style="cursor:pointer;color:var(--muted);font-weight:400;font-size:0.85rem">‚öô Opciones adicionales</summary>
          <div style="margin-top:10px">
            <div class="row">
              <div>
                <label for="fontSize">Tama√±o texto (px)</label>
                <input id="fontSize" type="number" value="36" min="8" max="200" />
              </div>
              <div>
                <label for="opacity">Opacidad: <span id="opacityVal">0.4</span></label>
                <input id="opacity" type="range" min="0.3" max="1" step="0.01" value="0.4" />
              </div>
            </div>
            <div class="row">
              <div>
                <label for="position">Posici√≥n marca de agua</label>
                <select id="position">
                  <option value="br">Abajo-Derecha</option>
                  <option value="bl">Abajo-Izquierda</option>
                  <option value="tl">Arriba-Izquierda</option>
                  <option value="tr">Arriba-Derecha</option>
                </select>
              </div>
              <div>
                <label for="rotation">Rotaci√≥n imagen</label>
                <select id="rotation">
                  <option value="0">0¬∞ (auto)</option>
                  <option value="90">90¬∞</option>
                  <option value="180">180¬∞</option>
                  <option value="270">270¬∞</option>
                </select>
              </div>
            </div>
          </div>
        </details>

        <div class="btns">
          <button class="secondary" id="btnPreview">Previsualizar</button>
          <button class="primary" id="btnProcess">Procesar y Guardar</button>
          <button class="danger" id="btnClear">Limpiar</button>
        </div>

        <p class="small" style="margin-top:10px">üì∑ La foto se guardar√° autom√°ticamente en Google Drive con marca de agua.</p>
      </section>

      <section class="card">
        <canvas id="canvas" class="preview" aria-label="Vista previa"></canvas>
        <div class="kv">
          <div class="chip" id="infoDim">‚Äî</div>
          <div class="chip" id="infoSize">‚Äî</div>
          <div class="chip" id="infoName">‚Äî</div>
        </div>
        <div class="btns">
          <a id="downloadLink" download style="display:none"><button class="primary">Descargar imagen</button></a>
        </div>
      </section>
    </div>

    <footer>Sistema de marcaci√≥n de fotos - Versi√≥n 1.0</footer>
  </div>

  <!-- PWA: manifest + SW generados al vuelo -->
  <script>
    (function(){
      function makeIcon(size){
        const c=document.createElement('canvas'); c.width=c.height=size; const x=c.getContext('2d');
        x.fillStyle='#0f172a'; x.fillRect(0,0,size,size);
        const g=x.createLinearGradient(0,0,size,size); g.addColorStop(0,'#22c55e'); g.addColorStop(1,'#3b82f6');
        x.fillStyle=g; x.beginPath(); x.arc(size/2,size/2,size*0.44,0,Math.PI*2); x.fill();
        x.fillStyle='#fff'; x.font=`${Math.round(size*0.28)}px system-ui, sans-serif`; x.textAlign='center'; x.textBaseline='middle';
        x.fillText('WM', size/2, size/2);
        return c.toDataURL('image/png');
      }
      const icon192 = makeIcon(192);
      const icon512 = makeIcon(512);

      const manifest = {
        name: 'Marcaci√≥n de Fotos',
        short_name: 'MarcaFotos',
        description: 'Registra y marca fotos con informaci√≥n del proyecto, local y offline.',
        start_url: './',
        scope: './',
        display: 'standalone',
        background_color: '#0f172a',
        theme_color: '#0f172a',
        icons: [{ src: icon192, sizes:'192x192', type:'image/png' }, { src: icon512, sizes:'512x512', type:'image/png' }]
      };
      const murl = URL.createObjectURL(new Blob([JSON.stringify(manifest)], {type:'application/json'}));
      document.getElementById('manifestLink').href = murl;
      document.getElementById('appleTouchIcon').href = icon192;

      const swCode = `
        const CACHE_NAME='wm-pwa-v1';
        const CORE=self.registration.scope?[self.registration.scope]:['/'];
        self.addEventListener('install',e=>{
          e.waitUntil(caches.open(CACHE_NAME).then(c=>c.addAll(CORE)).then(()=>self.skipWaiting()));
        });
        self.addEventListener('activate',e=>{
          e.waitUntil(caches.keys().then(keys=>Promise.all(keys.filter(k=>k!==CACHE_NAME).map(k=>caches.delete(k)))) .then(()=>self.clients.claim()));
        });
        self.addEventListener('fetch',e=>{
          const req=e.request;
          if(req.mode==='navigate'||(req.method==='GET'&&req.headers.get('accept')?.includes('text/html'))){
            e.respondWith(fetch(req).then(r=>{const copy=r.clone(); caches.open(CACHE_NAME).then(c=>c.put(req,copy)); return r;})
              .catch(()=>caches.match(req).then(r=>r||caches.match('/'))));
            return;
          }
          if(req.method==='GET'){
            e.respondWith(caches.match(req).then(cached=>{
              const fetchP=fetch(req).then(net=>{caches.open(CACHE_NAME).then(c=>c.put(req,net.clone())); return net;}).catch(()=>cached);
              return cached||fetchP;
            }));
          }
        });
      `;
      // Registrar ServiceWorker para funcionalidad offline completa
      if('serviceWorker' in navigator){
        const swUrl=URL.createObjectURL(new Blob([swCode],{type:'text/javascript'}));
        navigator.serviceWorker.register(swUrl)
          .then(reg => console.log('‚úÖ Service Worker registrado'))
          .catch(err => console.warn('‚ö†Ô∏è Error registrando SW:', err));
      }

      let deferredPrompt=null;
      const installBtn=document.getElementById('installBtn');
      window.addEventListener('beforeinstallprompt',(e)=>{
        e.preventDefault(); deferredPrompt=e; installBtn.style.display='inline-flex';
      });
      installBtn?.addEventListener('click', async ()=>{
        if(!deferredPrompt) return;
        deferredPrompt.prompt();
        await deferredPrompt.userChoice;
        deferredPrompt=null; installBtn.style.display='none';
      });
    })();
  </script>

  <!-- L√ìGICA DE LA APP -->
  <script>
    const $=(id)=>document.getElementById(id);
    const fileEl=$("file"), fechaCreacionEl=$("fechaCreacion"), fechaEl=$("fecha"),
          areaEl=$("area"), frenteEl=$("frente"), descripcionFotoEl=$("descripcionFoto"),
          observacionesEl=$("observaciones"), positionEl=$("position"), fontSizeEl=$("fontSize"),
          opacityEl=$("opacity"), opacityVal=$("opacityVal"), rotationEl=$("rotation"),
          btnPreview=$("btnPreview"), btnProcess=$("btnProcess"), btnClear=$("btnClear"),
          canvas=$("canvas"), ctx=canvas.getContext("2d"),
          infoDim=$("infoDim"), infoSize=$("infoSize"), infoName=$("infoName"),
          downloadLink=$("downloadLink");
    
    // URL del Google Apps Script
    const GAS_URL = 'https://script.google.com/a/macros/sedic.com.co/s/AKfycbwb-1q2Rd4TBxL5GDDMzc3PL9lkKuy3VIPOWw67bKvwH4oh6yoCmAa46UqJWY75G612/exec';
    
    // Configuraci√≥n de √°reas y frentes (se cargar√° din√°micamente)
    let areasFrentes = {};
    
    // Base de datos IndexedDB
    let db = null;
    const DB_NAME = 'MarcacionFotosDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'fotos';
    
    // Estado de sincronizaci√≥n
    let isSyncing = false;
    let isOnline = navigator.onLine;

    // Event listeners
    opacityEl.addEventListener('input',()=>opacityVal.textContent=opacityEl.value);
    
    // ========================================
    // SISTEMA DE ALMACENAMIENTO OFFLINE
    // ========================================
    
    /**
     * Inicializar IndexedDB
     */
    async function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => {
          console.error('‚ùå Error abriendo IndexedDB:', request.error);
          reject(request.error);
        };
        
        request.onsuccess = () => {
          db = request.result;
          console.log('‚úÖ IndexedDB inicializado');
          resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          
          // Crear object store si no existe
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
            
            // Crear √≠ndices
            objectStore.createIndex('status', 'status', { unique: false });
            objectStore.createIndex('timestamp', 'timestamp', { unique: false });
            objectStore.createIndex('filename', 'filename', { unique: false });
            
            console.log('‚úÖ Object store creado');
          }
        };
      });
    }
    
    /**
     * Guardar foto en IndexedDB
     */
    async function saveFotoToDB(fotoData) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const objectStore = transaction.objectStore(STORE_NAME);
        
        const foto = {
          ...fotoData,
          timestamp: new Date().toISOString(),
          status: 'pending' // pending, syncing, synced, error
        };
        
        const request = objectStore.add(foto);
        
        request.onsuccess = () => {
          console.log('‚úÖ Foto guardada en IndexedDB:', request.result);
          resolve(request.result);
        };
        
        request.onerror = () => {
          console.error('‚ùå Error guardando foto:', request.error);
          reject(request.error);
        };
      });
    }
    
    /**
     * Obtener todas las fotos pendientes
     */
    async function getPendingFotos() {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const objectStore = transaction.objectStore(STORE_NAME);
        const index = objectStore.index('status');
        const request = index.getAll('pending');
        
        request.onsuccess = () => {
          resolve(request.result);
        };
        
        request.onerror = () => {
          reject(request.error);
        };
      });
    }
    
    /**
     * Actualizar estado de una foto
     */
    async function updateFotoStatus(id, status, driveUrl = null, error = null) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const objectStore = transaction.objectStore(STORE_NAME);
        const request = objectStore.get(id);
        
        request.onsuccess = () => {
          const foto = request.result;
          foto.status = status;
          if (driveUrl) foto.driveUrl = driveUrl;
          if (error) foto.error = error;
          foto.syncedAt = new Date().toISOString();
          
          const updateRequest = objectStore.put(foto);
          
          updateRequest.onsuccess = () => {
            resolve();
          };
          
          updateRequest.onerror = () => {
            reject(updateRequest.error);
          };
        };
        
        request.onerror = () => {
          reject(request.error);
        };
      });
    }
    
    /**
     * Obtener conteo de fotos pendientes
     */
    async function getPendingCount() {
      const pending = await getPendingFotos();
      return pending.length;
    }
    
    /**
     * Eliminar fotos sincronizadas antiguas (m√°s de 7 d√≠as)
     */
    async function cleanOldSyncedFotos() {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const objectStore = transaction.objectStore(STORE_NAME);
        const request = objectStore.openCursor();
        
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        
        request.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            const foto = cursor.value;
            if (foto.status === 'synced' && new Date(foto.syncedAt) < sevenDaysAgo) {
              cursor.delete();
              console.log('üóëÔ∏è Foto sincronizada antigua eliminada:', foto.filename);
            }
            cursor.continue();
          } else {
            resolve();
          }
        };
        
        request.onerror = () => {
          reject(request.error);
        };
      });
    }
    
    // Event listeners
    opacityEl.addEventListener('input',()=>opacityVal.textContent=opacityEl.value);
    
    // ========================================
    // SISTEMA DE SINCRONIZACI√ìN
    // ========================================
    
    /**
     * Sincronizar fotos pendientes con Google Drive
     */
    async function syncPendingFotos() {
      if (isSyncing) {
        console.log('‚è≥ Sincronizaci√≥n ya en progreso...');
        return;
      }
      
      if (!isOnline) {
        console.log('üì¥ Sin conexi√≥n, sincronizaci√≥n cancelada');
        return;
      }
      
      isSyncing = true;
      updateSyncUI();
      
      try {
        const pending = await getPendingFotos();
        console.log(`üì§ Sincronizando ${pending.length} fotos pendientes...`);
        
        if (pending.length === 0) {
          console.log('‚úÖ No hay fotos pendientes');
          isSyncing = false;
          updateSyncUI();
          return;
        }
        
        let syncedCount = 0;
        let errorCount = 0;
        
        for (const foto of pending) {
          try {
            console.log(`üì§ Sincronizando: ${foto.filename}`);
            
            // Actualizar estado a "syncing"
            await updateFotoStatus(foto.id, 'syncing');
            updateSyncUI();
            
            // Enviar a Google Drive
            const response = await sendToGAS(foto.data);
            
            if (response.success) {
              // Marcar como sincronizada
              await updateFotoStatus(foto.id, 'synced', response.data?.driveUrl);
              syncedCount++;
              console.log(`‚úÖ Sincronizada: ${foto.filename}`);
            } else {
              // Marcar como error
              await updateFotoStatus(foto.id, 'error', null, response.message);
              errorCount++;
              console.error(`‚ùå Error sincronizando: ${foto.filename}`, response.message);
            }
            
          } catch (error) {
            // Marcar como error
            await updateFotoStatus(foto.id, 'error', null, error.message);
            errorCount++;
            console.error(`‚ùå Error sincronizando: ${foto.filename}`, error);
          }
          
          updateSyncUI();
        }
        
        console.log(`‚úÖ Sincronizaci√≥n completa: ${syncedCount} exitosas, ${errorCount} errores`);
        
        // Mostrar notificaci√≥n de resultado
        if (syncedCount > 0) {
          showSyncResultModal(syncedCount, errorCount);
        }
        
        // Limpiar fotos sincronizadas antiguas
        await cleanOldSyncedFotos();
        
      } catch (error) {
        console.error('‚ùå Error en sincronizaci√≥n:', error);
      } finally {
        isSyncing = false;
        updateSyncUI();
      }
    }
    
    /**
     * Detectar cambios en la conexi√≥n
     */
    window.addEventListener('online', () => {
      console.log('üåê Conexi√≥n restaurada');
      isOnline = true;
      updateSyncUI();
      
      // Sincronizar autom√°ticamente cuando se recupera la conexi√≥n
      setTimeout(() => {
        syncPendingFotos();
      }, 2000);
    });
    
    window.addEventListener('offline', () => {
      console.log('üì¥ Conexi√≥n perdida');
      isOnline = false;
      updateSyncUI();
    });
    
    /**
     * Actualizar UI de sincronizaci√≥n
     */
    async function updateSyncUI() {
      const pendingCount = await getPendingCount();
      
      // Actualizar badge de fotos pendientes
      let badge = document.getElementById('sync-badge');
      if (!badge && pendingCount > 0) {
        // Crear badge si no existe
        badge = document.createElement('div');
        badge.id = 'sync-badge';
        badge.style.cssText = `
          position: fixed; top: 20px; right: 20px; 
          background: ${isOnline ? '#3b82f6' : '#ef4444'}; 
          color: white; padding: 10px 16px; border-radius: 20px;
          font-weight: 600; font-size: 0.9rem; z-index: 999;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          cursor: pointer; transition: all 0.3s;
          display: flex; align-items: center; gap: 8px;
        `;
        badge.onclick = () => showPendingFotosModal();
        document.body.appendChild(badge);
      }
      
      if (badge) {
        if (pendingCount > 0) {
          const statusIcon = isSyncing ? '‚è≥' : (isOnline ? 'üì§' : 'üì¥');
          const statusText = isSyncing ? 'Sincronizando...' : `${pendingCount} pendiente${pendingCount > 1 ? 's' : ''}`;
          badge.innerHTML = `${statusIcon} ${statusText}`;
          badge.style.background = isSyncing ? '#f59e0b' : (isOnline ? '#3b82f6' : '#ef4444');
          badge.style.display = 'flex';
        } else {
          badge.style.display = 'none';
        }
      }
    }
    
    // Funci√≥n para obtener fecha/hora de Bogot√° usando la API nativa
    function getBogotaTime() {
      // Usar la API de zona horaria nativa del navegador
      const now = new Date();
      const bogotaTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Bogota"}));
      return bogotaTime;
    }
    
    function getBogotaDateTimeForInput() {
      // Para el input datetime-local, crear la fecha directamente en formato local
      const now = new Date();
      
      // Obtener los componentes de fecha/hora en zona horaria de Bogot√°
      const bogotaFormatter = new Intl.DateTimeFormat('en-CA', {
        timeZone: 'America/Bogota',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
      });
      
      const parts = bogotaFormatter.formatToParts(now);
      const year = parts.find(p => p.type === 'year').value;
      const month = parts.find(p => p.type === 'month').value;
      const day = parts.find(p => p.type === 'day').value;
      const hour = parts.find(p => p.type === 'hour').value;
      const minute = parts.find(p => p.type === 'minute').value;
      
      return `${year}-${month}-${day}T${hour}:${minute}`;
    }
    
    function getBogotaISOString() {
      return getBogotaTime().toISOString();
    }
    
    // Mostrar hora actual de Bogot√° en la consola para verificaci√≥n
    const bogotaTimeString = new Date().toLocaleString('es-CO', {
      timeZone: 'America/Bogota',
      year: 'numeric',
      month: '2-digit', 
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
    console.log('üïê Hora actual de Bogot√°:', bogotaTimeString);
    
    // Inicializar fechas con zona horaria de Bogot√°
    fechaCreacionEl.value = getBogotaISOString();
    fechaEl.value = getBogotaDateTimeForInput();
    
    // Inicializar sistema offline
    (async () => {
      try {
        await initDB();
        await updateSyncUI();
        
        // Sincronizar autom√°ticamente si hay conexi√≥n
        if (isOnline) {
          setTimeout(() => {
            syncPendingFotos();
          }, 3000); // Esperar 3 segundos despu√©s de cargar
        }
        
        // Sincronizar cada 5 minutos si hay conexi√≥n
        setInterval(async () => {
          if (isOnline && !isSyncing) {
            const pendingCount = await getPendingCount();
            if (pendingCount > 0) {
              console.log('üîÑ Sincronizaci√≥n autom√°tica peri√≥dica...');
              syncPendingFotos();
            }
          }
        }, 5 * 60 * 1000); // 5 minutos
        
      } catch (error) {
        console.error('Error inicializando sistema offline:', error);
      }
    })();
    
    // Cargar √°reas y frentes desde la base de datos
    loadAreasFromSheets();
    
    // Manejar cambio de √°rea
    areaEl.addEventListener('change', ()=>{
      const area = areaEl.value;
      frenteEl.innerHTML = '<option value="">Selecciona un frente...</option>';
      
      if(area && areasFrentes[area]){
        frenteEl.disabled = false;
        areasFrentes[area].forEach(frente => {
          const option = document.createElement('option');
          option.value = frente;
          option.textContent = frente;
          frenteEl.appendChild(option);
        });
      } else {
        frenteEl.disabled = true;
        frenteEl.innerHTML = '<option value="">Primero selecciona un √°rea</option>';
      }
    });

    let loadedImg=null;

    fileEl.addEventListener('change', async (e)=>{
      const f=e.target.files?.[0]; if(!f) return;
      const url=URL.createObjectURL(f); const img=new Image();
      await new Promise((res,rej)=>{img.onload=res; img.onerror=rej; img.src=url;});
      loadedImg={image:img,width:img.naturalWidth,height:img.naturalHeight,name:f.name,size:f.size};
      infoDim.textContent=`${img.naturalWidth}√ó${img.naturalHeight}px`;
      infoSize.textContent=humanSize(f.size);
      infoName.textContent=f.name;
      updateFilename();
      drawPreview();
    });

    // Actualizar nombre de archivo cuando cambien los campos
    frenteEl.addEventListener('change', updateFilename);
    descripcionFotoEl.addEventListener('input', updateFilename);
    fechaEl.addEventListener('change', updateFilename);

    btnPreview.addEventListener('click',(e)=>{e.preventDefault(); drawPreview();});
    
    btnProcess.addEventListener('click', async (e)=>{
      e.preventDefault();
      if(!validateForm()) return;
      
      // Mostrar indicador de procesamiento
      btnProcess.textContent = 'Procesando...';
      btnProcess.disabled = true;
      
      try {
        // Actualizar fecha de creaci√≥n al momento exacto del procesamiento
        fechaCreacionEl.value = getBogotaISOString();
        
        console.log('üìÖ Fechas al procesar:');
        console.log('  CREACION:', fechaCreacionEl.value);
        console.log('  FECHA:', fechaEl.value);
        console.log('  ¬øSon iguales?', fechaCreacionEl.value === fechaEl.value);
        
        // Procesar imagen con marca de agua
        await drawPreview(true);
        const filename = generateFilename();
        const blob = await new Promise(res=>canvas.toBlob(res,'image/jpeg',0.9));
        
        // Convertir blob a base64
        const imageBase64 = await blobToBase64(blob);
        
        // Convertir fecha del input datetime-local a ISO string para consistencia
        const fechaISO = fechaEl.value ? new Date(fechaEl.value).toISOString() : fechaCreacionEl.value;
        
        // Preparar datos para env√≠o
        const formData = {
          fechaCreacion: fechaCreacionEl.value,
          fecha: fechaISO,
          area: areaEl.value,
          frente: frenteEl.value,
          descripcionFoto: descripcionFotoEl.value,
          observaciones: observacionesEl.value,
          filename: filename,
          imageBase64: imageBase64
        };
        
        console.log('üìã Datos preparados para env√≠o:', {
          fechaCreacion: formData.fechaCreacion,
          fecha: formData.fecha,
          area: formData.area,
          frente: formData.frente,
          descripcionFoto: formData.descripcionFoto,
          observaciones: formData.observaciones,
          filename: formData.filename,
          imageSize: formData.imageBase64 ? (formData.imageBase64.length / 1024).toFixed(1) + 'KB' : 'No image'
        });
        
        // Guardar descarga local
        const dl = URL.createObjectURL(blob);
        downloadLink.href = dl;
        downloadLink.download = `${filename}.jpg`;
        downloadLink.style.display = 'inline-block';
        downloadLink.querySelector('button').textContent = `Descargar ${filename}.jpg`;
        setTimeout(()=>URL.revokeObjectURL(dl), 60000);
        
        // Verificar conexi√≥n
        if (!isOnline) {
          console.log('üì¥ Sin conexi√≥n - Guardando localmente');
          
          // Guardar en IndexedDB
          await saveFotoToDB({
            filename: filename,
            data: formData
          });
          
          await updateSyncUI();
          
          showOfflineSuccessModal(filename + '.jpg');
          
          // Limpiar formulario
          btnClear.click();
          
        } else {
          // Intentar enviar a Google Apps Script
          try {
            const response = await sendToGAS(formData);
            
            if (response.success) {
              // Ahora podemos acceder a la URL real de Drive desde la respuesta
              const driveUrl = response.data?.driveUrl || null;
              const fileName = response.data?.fileName || (filename + '.jpg');
              
              showSuccessModal(fileName, driveUrl);
              
              // Limpiar formulario despu√©s del √©xito
              btnClear.click();
              
            } else {
              throw new Error(response.message || 'Error desconocido del servidor');
            }
          } catch (error) {
            console.error('Error enviando a Drive, guardando localmente:', error);
            
            // Si falla el env√≠o, guardar localmente
            await saveFotoToDB({
              filename: filename,
              data: formData
            });
            
            await updateSyncUI();
            
            showOfflineFallbackModal(filename + '.jpg', error.message);
            
            // Limpiar formulario
            btnClear.click();
          }
        }
        
      } catch (error) {
        console.error('Error procesando foto:', error);
        showErrorModal(error.message);
      } finally {
        // Restaurar bot√≥n
        btnProcess.textContent = 'Procesar y Guardar';
        btnProcess.disabled = false;
      }
    });
    
    btnClear.addEventListener('click',(e)=>{
      e.preventDefault(); 
      // Limpiar formulario
      fileEl.value=''; 
      fechaEl.value = getBogotaDateTimeForInput(); // Usar funci√≥n de Bogot√°
      areaEl.value='';
      frenteEl.value='';
      frenteEl.disabled=true;
      descripcionFotoEl.value='';
      observacionesEl.value='';
      
      // Limpiar imagen
      loadedImg=null; 
      ctx.clearRect(0,0,canvas.width,canvas.height);
      infoDim.textContent='‚Äî'; 
      infoSize.textContent='‚Äî'; 
      infoName.textContent='‚Äî';
      downloadLink.style.display='none';
    });

    function baseName(name){ const dot=name.lastIndexOf('.'); return dot>-1?name.slice(0,dot):name; }
    function sanitize(str){ return str.trim().replace(/\s+/g,' ').replace(/[^a-zA-Z0-9\s\-]/g,''); }
    function humanSize(bytes){ const u=['B','KB','MB','GB']; let i=0,n=bytes; while(n>=1024&&i<u.length-1){n/=1024;i++;} return `${n.toFixed(1)} ${u[i]}`; }
    
    function validateForm(){
      if(!fechaEl.value){ 
        showValidationModal('Por favor selecciona una fecha', fechaEl); 
        return false; 
      }
      if(!areaEl.value){ 
        showValidationModal('Por favor selecciona un √°rea', areaEl); 
        return false; 
      }
      if(!frenteEl.value){ 
        showValidationModal('Por favor selecciona un frente', frenteEl); 
        return false; 
      }
      if(!loadedImg){ 
        showValidationModal('Por favor selecciona una imagen', fileEl); 
        return false; 
      }
      if(!descripcionFotoEl.value.trim()){ 
        showValidationModal('Por favor ingresa una descripci√≥n de la foto', descripcionFotoEl); 
        return false; 
      }
      return true;
    }
    
    function generateFilename(){
      const fecha = new Date(fechaEl.value);
      const yyyymmdd = fecha.toISOString().slice(0,10).replace(/-/g,'');
      const frente = sanitize(frenteEl.value);
      const descripcion = sanitize(descripcionFotoEl.value);
      return `${yyyymmdd}-${frente}-${descripcion}`;
    }
    
    function updateFilename(){
      if(fechaEl.value && frenteEl.value && descripcionFotoEl.value.trim()){
        const filename = generateFilename();
        infoName.textContent = `${filename}.jpg`;
      }
    }
    
    function formatDateTime(dateStr){
      // Convertir el datetime-local a fecha de Bogot√°
      // dateStr viene en formato "YYYY-MM-DDTHH:MM"
      const [datePart, timePart] = dateStr.split('T');
      const [year, month, day] = datePart.split('-');
      const [hours, minutes] = timePart.split(':');
      
      // Crear fecha en zona horaria de Bogot√° (sin conversi√≥n autom√°tica del navegador)
      const formattedDay = day.padStart(2,'0');
      const formattedMonth = month.padStart(2,'0');
      const formattedHours = hours.padStart(2,'0');
      const formattedMinutes = minutes.padStart(2,'0');
      
      return `${formattedDay}/${formattedMonth}/${year} ${formattedHours}:${formattedMinutes}`;
    }
    
    // Convertir blob a base64
    function blobToBase64(blob){
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(blob);
      });
    }
    
    // Cargar √°reas y frentes desde Google Sheets usando JSONP
    async function loadAreasFromSheets(){
      try {
        console.log('üîÑ Intentando cargar √°reas desde Sheets (JSONP)...');
        
        const data = await loadAreasWithJSONP();
        
        if (data && data.success && data.data) {
          areasFrentes = data.data;
          populateAreaSelect();
          console.log('‚úÖ √Åreas cargadas exitosamente desde Sheets:', Object.keys(areasFrentes));
          return;
        } else {
          console.warn('‚ö†Ô∏è Respuesta no exitosa desde GAS');
        }
      } catch (error) {
        console.error('‚ùå Error cargando √°reas:', error);
      }
      
      // Fallback: usar configuraci√≥n est√°tica
      console.log('üîÑ Usando configuraci√≥n por defecto...');
      areasFrentes = {
        "T√∫nel Gr√∫a Puente": ["T√∫nel Norte", "T√∫nel Sur", "Gr√∫a Puente Norte", "Gr√∫a Puente Sur"],
        "Casa de M√°quinas": ["Casa de M√°quinas Norte", "Casa de M√°quinas Sur", "Turbina 1", "Turbina 2", "Generador 1", "Generador 2"],
        "Transformador": ["Transformador Principal", "Transformador Auxiliar", "Patio de Maniobras"],
        "Vertedero": ["Vertedero Principal", "Canal de Descarga", "Compuertas"],
        "Embalse": ["Presa", "Coronamiento", "Talud Aguas Arriba", "Talud Aguas Abajo"],
        "Obra de Toma": ["Rejillas", "Compuertas de Toma", "T√∫nel de Conducci√≥n"]
      };
      populateAreaSelect();
      console.log('‚úÖ Configuraci√≥n por defecto aplicada');
    }
    
    // Funci√≥n JSONP para cargar √°reas sin problemas de CORS
    function loadAreasWithJSONP() {
      return new Promise((resolve, reject) => {
        const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random());
        
        // Crear funci√≥n callback global temporal
        window[callbackName] = function(data) {
          delete window[callbackName];
          document.body.removeChild(script);
          resolve(data);
        };
        
        // Crear script tag
        const script = document.createElement('script');
        script.src = GAS_URL + '?action=getAreas&callback=' + callbackName;
        
        // Manejar errores
        script.onerror = function() {
          delete window[callbackName];
          document.body.removeChild(script);
          reject(new Error('Error cargando script JSONP'));
        };
        
        // Timeout
        setTimeout(() => {
          if (window[callbackName]) {
            delete window[callbackName];
            document.body.removeChild(script);
            reject(new Error('Timeout JSONP'));
          }
        }, 10000);
        
        // Agregar script al DOM
        document.body.appendChild(script);
      });
    }
    
    // Poblar select de √°reas
    function populateAreaSelect(){
      console.log('üèóÔ∏è Poblando select de √°reas...');
      areaEl.innerHTML = '<option value="">Selecciona un √°rea...</option>';
      
      const areas = Object.keys(areasFrentes);
      console.log('üìã √Åreas disponibles:', areas);
      
      areas.forEach(area => {
        const option = document.createElement('option');
        option.value = area;
        option.textContent = area;
        areaEl.appendChild(option);
        console.log(`‚ûï √Årea agregada: ${area}`);
      });
      
      console.log(`‚úÖ ${areas.length} √°reas agregadas al select`);
    }

    // Enviar datos a Google Apps Script usando m√©todo h√≠brido
    async function sendToGAS(data){
      try {
        console.log('üì§ Enviando datos a GAS:', {
          filename: data.filename,
          area: data.area,
          frente: data.frente,
          descripcion: data.descripcionFoto,
          imageSize: (data.imageBase64.length / 1024).toFixed(1) + 'KB'
        });
        
        console.log('üöÄ Enviando datos via POST y consultando resultado via JSONP...');
        
        // Generar ID √∫nico para esta operaci√≥n
        const operationId = 'op_' + Date.now() + '_' + Math.round(Math.random() * 1000);
        
        // 1. Enviar datos via POST con no-cors (pero incluir operationId)
        const formData = new FormData();
        formData.append('data', JSON.stringify({...data, operationId}));
        
        const postPromise = fetch(GAS_URL, {
          method: 'POST',
          body: formData,
          mode: 'no-cors'
        });
        
        // 2. Esperar un momento y luego consultar el resultado via JSONP
        await postPromise;
        
        console.log('üì§ POST enviado, consultando resultado...');
        
        // Esperar un poco para que se procese
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // 3. Consultar resultado via JSONP
        const response = await getResultWithJSONP(operationId);
        
        console.log('‚úÖ Respuesta recibida:', response);
        
        return response;
        
      } catch (error) {
        console.error('‚ùå Error enviando a GAS:', error);
        throw new Error('Error de conexi√≥n: ' + error.message);
      }
    }
    
    // Funci√≥n JSONP para consultar resultado
    function getResultWithJSONP(operationId) {
      return new Promise((resolve, reject) => {
        const callbackName = 'jsonp_result_' + Math.round(100000 * Math.random());
        
        window[callbackName] = function(response) {
          delete window[callbackName];
          document.body.removeChild(script);
          resolve(response);
        };
        
        const params = new URLSearchParams({
          action: 'getResult',
          callback: callbackName,
          operationId: operationId
        });
        
        const script = document.createElement('script');
        script.src = GAS_URL + '?' + params.toString();
        
        script.onerror = function() {
          delete window[callbackName];
          document.body.removeChild(script);
          reject(new Error('Error consultando resultado'));
        };
        
        // Timeout m√°s largo para consulta de resultado
        setTimeout(() => {
          if (window[callbackName]) {
            delete window[callbackName];
            document.body.removeChild(script);
            reject(new Error('Timeout consultando resultado'));
          }
        }, 10000);
        
        document.body.appendChild(script);
      });
    }



    async function drawPreview(final=false){
      if(!loadedImg) return;
      const img=loadedImg.image, rot=Number(rotationEl.value);
      let targetW=img.naturalWidth, targetH=img.naturalHeight;
      
      // Redimensionar si es muy grande (max 2000px de ancho)
      const maxW = 2000;
      if(targetW > maxW){ 
        const s=maxW/targetW; 
        targetW=Math.round(targetW*s); 
        targetH=Math.round(targetH*s); 
      }
      
      const needsSwap=rot===90||rot===270;
      canvas.width=needsSwap?targetH:targetW; 
      canvas.height=needsSwap?targetW:targetH;

      // Dibujar imagen
      ctx.save();
      if(rot!==0){
        if(rot===90){ctx.translate(canvas.width,0); ctx.rotate(Math.PI/2);}
        if(rot===180){ctx.translate(canvas.width,canvas.height); ctx.rotate(Math.PI);}
        if(rot===270){ctx.translate(0,canvas.height); ctx.rotate(3*Math.PI/2);}
      }
      ctx.drawImage(img,0,0,targetW,targetH);
      ctx.restore();

      // Crear marca de agua con informaci√≥n del formulario
      if(fechaEl.value && frenteEl.value && descripcionFotoEl.value){
        const fechaFormateada = formatDateTime(fechaEl.value);
        const frente = frenteEl.value;
        const descripcion = descripcionFotoEl.value;
        
        const watermarkLines = [fechaFormateada, frente, descripcion];
        drawWatermark(watermarkLines);
      }

      // Actualizar informaci√≥n
      infoDim.textContent=`${canvas.width}√ó${canvas.height}px`;
      const blob=await new Promise(res=>canvas.toBlob(res,'image/jpeg',0.9));
      infoSize.textContent=humanSize(blob.size);
      updateFilename();
    }

    function drawWatermark(lines){
      const opacity=Number(opacityEl.value);
      const size=Number(fontSizeEl.value);
      const pos=positionEl.value;
      const margin=20;
      const lineHeight=size*1.2;
      const padding = 16;
      
      ctx.save();
      ctx.globalAlpha=opacity;
      ctx.fillStyle='rgba(0,0,0,0.7)'; // Fondo semitransparente
      ctx.font=`600 ${size}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
      
      // Calcular dimensiones del bloque de texto
      const maxWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
      const blockWidth = maxWidth + (padding * 2);
      const blockHeight = (lines.length * lineHeight) + padding;
      
      // Calcular posici√≥n
      let x = margin, y = margin;
      if(pos==='br'){ x = canvas.width - blockWidth - margin; y = canvas.height - blockHeight - margin; }
      if(pos==='bl'){ x = margin; y = canvas.height - blockHeight - margin; }
      if(pos==='tr'){ x = canvas.width - blockWidth - margin; y = margin; }
      if(pos==='tl'){ x = margin; y = margin; }
      
      // Dibujar fondo redondeado
      roundRect(ctx, x, y, blockWidth, blockHeight, 8);
      ctx.fill();
      
      // Dibujar texto alineado a la derecha
      ctx.fillStyle='#ffffff';
      ctx.globalAlpha=Math.min(1, opacity + 0.3);
      ctx.textAlign = 'right'; // Alineaci√≥n a la derecha
      
      lines.forEach((line, index) => {
        const textY = y + padding + (index * lineHeight) + (size * 0.7);
        const textX = x + blockWidth - padding; // Posici√≥n X para alineaci√≥n derecha
        ctx.fillText(line, textX, textY);
      });
      
      ctx.restore();
    }

    function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }
    
    // Modales mejorados
    function showSuccessModal(fileName, driveUrl) {
      const modal = createModal(`
        <div style="text-align: center; padding: 24px;">
          <div style="width: 60px; height: 60px; margin: 0 auto 20px; background: #22c55e; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3">
              <polyline points="20,6 9,17 4,12"></polyline>
            </svg>
          </div>
          <h3 style="color: #e5e7eb; margin: 0 0 12px 0; font-size: 1.3rem; font-weight: 600;">Foto guardada</h3>
          <p style="margin: 0 0 20px 0; color: #94a3b8; font-size: 0.95rem;">
            <strong style="color: #e5e7eb;">${fileName}</strong> se ha guardado correctamente
          </p>
          
          ${driveUrl ? `
          <div style="margin: 20px 0;">
            <a href="${driveUrl}" target="_blank" style="
              display: inline-flex; align-items: center; gap: 8px; padding: 12px 20px; 
              background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; 
              text-decoration: none; border-radius: 8px; font-weight: 500;
              transition: all 0.2s; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 6px 20px rgba(59, 130, 246, 0.4)'" 
               onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(59, 130, 246, 0.3)'">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
              </svg>
              Ver en Google Drive
            </a>
          </div>` : ''}
          
          <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid #374151;">
            <button onclick="closeModal()" style="
              padding: 10px 24px; background: #374151; color: #e5e7eb; 
              border: none; border-radius: 6px; cursor: pointer; font-weight: 500;
              transition: background 0.2s;
            " onmouseover="this.style.background='#4b5563'" onmouseout="this.style.background='#374151'">
              Cerrar
            </button>
          </div>
        </div>
      `);
    }
    
    function showErrorModal(errorMessage) {
      const modal = createModal(`
        <div style="text-align: center; padding: 24px;">
          <div style="width: 60px; height: 60px; margin: 0 auto 20px; background: #ef4444; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="15" y1="9" x2="9" y2="15"></line>
              <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
          </div>
          <h3 style="color: #e5e7eb; margin: 0 0 12px 0; font-size: 1.3rem; font-weight: 600;">Error al guardar</h3>
          <p style="margin: 0 0 16px 0; color: #94a3b8; font-size: 0.95rem;">
            ${errorMessage}
          </p>
          <div style="margin: 20px 0; padding: 16px; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.2); border-radius: 8px;">
            <div style="display: flex; align-items: center; gap: 8px; color: #f59e0b; font-size: 0.9rem;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="m9 12 2 2 4-4"></path>
              </svg>
              Puedes descargar la imagen localmente
            </div>
          </div>
          <button onclick="closeModal()" style="
            padding: 10px 24px; background: #374151; color: #e5e7eb; 
            border: none; border-radius: 6px; cursor: pointer; font-weight: 500;
            transition: background 0.2s;
          " onmouseover="this.style.background='#4b5563'" onmouseout="this.style.background='#374151'">
            Cerrar
          </button>
        </div>
      `);
    }
    
    function showValidationModal(message, focusElement) {
      const modal = createModal(`
        <div style="text-align: center; padding: 24px;">
          <div style="width: 60px; height: 60px; margin: 0 auto 20px; background: #f59e0b; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="12" y1="8" x2="12" y2="12"></line>
              <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
          </div>
          <h3 style="color: #e5e7eb; margin: 0 0 12px 0; font-size: 1.3rem; font-weight: 600;">Campo requerido</h3>
          <p style="margin: 0 0 24px 0; color: #94a3b8; font-size: 0.95rem;">
            ${message}
          </p>
          <button onclick="closeModal(); focusField('${focusElement.id}')" style="
            padding: 10px 24px; background: #f59e0b; color: white; 
            border: none; border-radius: 6px; cursor: pointer; font-weight: 500;
            transition: background 0.2s;
          " onmouseover="this.style.background='#d97706'" onmouseout="this.style.background='#f59e0b'">
            Entendido
          </button>
        </div>
      `);
    }
    
    function showOfflineSuccessModal(fileName) {
      const modal = createModal(`
        <div style="text-align: center; padding: 24px;">
          <div style="width: 60px; height: 60px; margin: 0 auto 20px; background: #3b82f6; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
          </div>
          <h3 style="color: #e5e7eb; margin: 0 0 12px 0; font-size: 1.3rem; font-weight: 600;">Guardado localmente</h3>
          <p style="margin: 0 0 16px 0; color: #94a3b8; font-size: 0.95rem;">
            <strong style="color: #e5e7eb;">${fileName}</strong> se guard√≥ en tu dispositivo
          </p>
          <div style="margin: 20px 0; padding: 16px; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 8px;">
            <div style="color: #3b82f6; font-size: 0.9rem;">
              üì¥ Sin conexi√≥n a internet<br>
              <span style="color: #94a3b8; font-size: 0.85rem;">Se sincronizar√° autom√°ticamente cuando te conectes</span>
            </div>
          </div>
          <button onclick="closeModal()" style="
            padding: 10px 24px; background: #374151; color: #e5e7eb; 
            border: none; border-radius: 6px; cursor: pointer; font-weight: 500;
            transition: background 0.2s;
          " onmouseover="this.style.background='#4b5563'" onmouseout="this.style.background='#374151'">
            Cerrar
          </button>
        </div>
      `);
    }
    
    function showOfflineFallbackModal(fileName, errorMsg) {
      const modal = createModal(`
        <div style="text-align: center; padding: 24px;">
          <div style="width: 60px; height: 60px; margin: 0 auto 20px; background: #f59e0b; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
          </div>
          <h3 style="color: #e5e7eb; margin: 0 0 12px 0; font-size: 1.3rem; font-weight: 600;">Guardado localmente</h3>
          <p style="margin: 0 0 16px 0; color: #94a3b8; font-size: 0.95rem;">
            No se pudo enviar a Drive, pero <strong style="color: #e5e7eb;">${fileName}</strong> se guard√≥ localmente
          </p>
          <div style="margin: 20px 0; padding: 16px; background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.2); border-radius: 8px;">
            <div style="color: #f59e0b; font-size: 0.85rem; margin-bottom: 8px;">
              Error: ${errorMsg}
            </div>
            <div style="color: #94a3b8; font-size: 0.85rem;">
              Se reintentar√° autom√°ticamente
            </div>
          </div>
          <button onclick="closeModal()" style="
            padding: 10px 24px; background: #374151; color: #e5e7eb; 
            border: none; border-radius: 6px; cursor: pointer; font-weight: 500;
            transition: background 0.2s;
          " onmouseover="this.style.background='#4b5563'" onmouseout="this.style.background='#374151'">
            Cerrar
          </button>
        </div>
      `);
    }
    
    function showSyncResultModal(syncedCount, errorCount) {
      const modal = createModal(`
        <div style="text-align: center; padding: 24px;">
          <div style="width: 60px; height: 60px; margin: 0 auto 20px; background: #22c55e; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5">
              <polyline points="23 4 23 10 17 10"></polyline>
              <polyline points="1 20 1 14 7 14"></polyline>
              <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
          </div>
          <h3 style="color: #e5e7eb; margin: 0 0 12px 0; font-size: 1.3rem; font-weight: 600;">Sincronizaci√≥n completada</h3>
          <p style="margin: 0 0 20px 0; color: #94a3b8; font-size: 0.95rem;">
            ${syncedCount} foto${syncedCount > 1 ? 's sincronizadas' : ' sincronizada'} correctamente
            ${errorCount > 0 ? `<br><span style="color: #ef4444;">${errorCount} error${errorCount > 1 ? 'es' : ''}</span>` : ''}
          </p>
          <button onclick="closeModal()" style="
            padding: 10px 24px; background: #22c55e; color: white; 
            border: none; border-radius: 6px; cursor: pointer; font-weight: 500;
            transition: background 0.2s;
          " onmouseover="this.style.background='#16a34a'" onmouseout="this.style.background='#22c55e'">
            Cerrar
          </button>
        </div>
      `);
    }
    
    async function showPendingFotosModal() {
      const pending = await getPendingFotos();
      const synced = await getAllSyncedFotos();
      
      let listHtml = '';
      
      if (pending.length > 0) {
        listHtml += '<div style="margin-bottom: 20px;"><h4 style="color: #3b82f6; margin: 0 0 12px 0; font-size: 1rem;">üì§ Pendientes de sincronizar</h4>';
        pending.forEach(foto => {
          const statusColor = foto.status === 'syncing' ? '#f59e0b' : (foto.status === 'error' ? '#ef4444' : '#3b82f6');
          const statusText = foto.status === 'syncing' ? 'Sincronizando...' : (foto.status === 'error' ? 'Error' : 'Pendiente');
          listHtml += `
            <div style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 8px; text-align: left;">
              <div style="color: #e5e7eb; font-weight: 500; font-size: 0.9rem;">${foto.filename}</div>
              <div style="color: ${statusColor}; font-size: 0.85rem; margin-top: 4px;">${statusText}</div>
              ${foto.error ? `<div style="color: #ef4444; font-size: 0.8rem; margin-top: 4px;">${foto.error}</div>` : ''}
            </div>
          `;
        });
        listHtml += '</div>';
      }
      
      if (synced.length > 0) {
        listHtml += '<div><h4 style="color: #22c55e; margin: 0 0 12px 0; font-size: 1rem;">‚úÖ Sincronizadas recientemente</h4>';
        synced.slice(0, 5).forEach(foto => {
          listHtml += `
            <div style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 8px; text-align: left;">
              <div style="color: #e5e7eb; font-weight: 500; font-size: 0.9rem;">${foto.filename}</div>
              <div style="color: #22c55e; font-size: 0.85rem; margin-top: 4px;">Sincronizada</div>
              ${foto.driveUrl ? `<a href="${foto.driveUrl}" target="_blank" style="color: #3b82f6; font-size: 0.85rem; text-decoration: none;">Ver en Drive ‚Üí</a>` : ''}
            </div>
          `;
        });
        listHtml += '</div>';
      }
      
      if (pending.length === 0 && synced.length === 0) {
        listHtml = '<p style="color: #94a3b8; text-align: center; padding: 20px;">No hay fotos guardadas</p>';
      }
      
      const modal = createModal(`
        <div style="padding: 24px;">
          <h3 style="color: #e5e7eb; margin: 0 0 20px 0; font-size: 1.3rem; font-weight: 600; text-align: center;">Fotos guardadas</h3>
          <div style="max-height: 400px; overflow-y: auto;">
            ${listHtml}
          </div>
          <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: center;">
            ${pending.length > 0 && isOnline ? `
              <button onclick="closeModal(); syncPendingFotos();" style="
                padding: 10px 20px; background: #3b82f6; color: white; 
                border: none; border-radius: 6px; cursor: pointer; font-weight: 500;
              ">
                Sincronizar ahora
              </button>
            ` : ''}
            <button onclick="closeModal()" style="
              padding: 10px 20px; background: #374151; color: #e5e7eb; 
              border: none; border-radius: 6px; cursor: pointer; font-weight: 500;
            ">
              Cerrar
            </button>
          </div>
        </div>
      `);
    }
    
    async function getAllSyncedFotos() {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const objectStore = transaction.objectStore(STORE_NAME);
        const index = objectStore.index('status');
        const request = index.getAll('synced');
        
        request.onsuccess = () => {
          const fotos = request.result;
          fotos.sort((a, b) => new Date(b.syncedAt) - new Date(a.syncedAt));
          resolve(fotos);
        };
        
        request.onerror = () => {
          reject(request.error);
        };
      });
    }
    
    function focusField(elementId) {
      const element = document.getElementById(elementId);
      if (element) {
        element.focus();
        // Scroll al elemento si est√° fuera de vista
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
    
    function createModal(content) {
      // Crear backdrop
      const backdrop = document.createElement('div');
      backdrop.id = 'modal-backdrop';
      backdrop.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center;
        z-index: 1000; animation: fadeIn 0.2s ease;
      `;
      
      // Crear modal
      const modal = document.createElement('div');
      modal.style.cssText = `
        background: #111827; border-radius: 12px; border: 1px solid #374151;
        max-width: 400px; width: 90%; max-height: 90%; overflow-y: auto;
        box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        animation: slideIn 0.3s ease;
      `;
      modal.innerHTML = content;
      
      backdrop.appendChild(modal);
      document.body.appendChild(backdrop);
      
      // Cerrar al hacer clic en el backdrop
      backdrop.addEventListener('click', (e) => {
        if (e.target === backdrop) closeModal();
      });
      
      return modal;
    }
    
    function closeModal() {
      const backdrop = document.getElementById('modal-backdrop');
      if (backdrop) {
        backdrop.remove();
      }
    }
    
    // Agregar estilos para las animaciones
    const style = document.createElement('style');
    style.textContent = `
      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
      @keyframes slideIn { from { transform: scale(0.9) translateY(-10px); opacity: 0; } to { transform: scale(1) translateY(0); opacity: 1; } }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>
